---
layout: post
title: 十二因子 tweleve factor
date: 2025-09-11 01:59:00
description: 云原生对应用设计的要求
tags: architect, arch, cloudnative, CN, stateless
categories: architect-theory
thumbnail: assets/img/9.jpg
images:
  lightbox2: true
  photoswipe: true
  spotlight: true
  venobox: true
---

# 十二要素应用程序方法论

在现代，软件通常以服务的形式交付：称为*Web应用程序*或*软件即服务*。十二要素应用程序是一种构建软件即服务应用程序的方法论，它：

* 使用**声明式**格式进行设置自动化，以最小化新开发人员加入项目的时间和成本；
* 与底层操作系统有**清晰的契约**，在执行环境之间提供**最大的可移植性**；
* 适用于现代**云平台**部署，无需服务器和系统管理；
* **最小化**开发和生产环境之间的差异，实现**持续部署**以获得最大敏捷性；
* 可以**横向扩展**而无需对工具、架构或开发实践进行重大更改。

十二要素方法论可以应用于任何编程语言编写的应用程序，以及使用任何组合的后端服务（数据库、队列、内存缓存等）的应用程序。

## I. 代码库
### 一个代码库由版本控制系统管理，多个部署

#### 1. 十二要素应用程序始终由版本控制系统跟踪。

十二要素应用程序始终由版本控制系统跟踪。版本跟踪数据库的副本被称为*代码仓库*，通常简称为*代码库*或*仓库*。

版本控制系统的示例包括[Git](http://git-scm.com/)、[Mercurial](https://www.mercurial-scm.org/)和[Subversion](http://subversion.apache.org/)。

*代码库*是指任何单个仓库（在像Subversion这样的集中式版本控制系统中），或任何共享根提交的仓库集（在像Git这样的去中心化版本控制系统中）。

#### 2. 代码库与应用程序之间始终存在一对一的关系。

代码库与应用程序之间始终存在一对一的关系：

* 如果有多个代码库，那就不是一个应用程序——而是一个分布式系统。分布式系统中的每个组件都是一个应用程序，每个组件都可以单独符合十二要素。
* 多个应用程序共享相同代码违反了十二要素。

#### 3. 一个代码库可以部署在多个环境中。

每个应用程序只有一个代码库，但应用程序会有许多部署。*部署*是应用程序的运行实例，通常是一个生产站点加上一个或多个预发布站点。此外，每个开发人员在本地开发环境中都有一个应用程序副本，每个副本也都符合部署的条件。

所有部署中的代码库都是相同的，尽管每个部署中可能激活不同的版本。例如，开发人员可能有一些尚未部署到预发布的提交；预发布可能有一些尚未部署到生产的提交。但它们都共享相同的代码库，使它们可以被识别为同一应用程序的不同部署。

## II. 依赖
### 显式声明和隔离依赖

#### 1. 十二要素应用程序在确定性的环境中构建和运行。

显式依赖声明的一个好处是简化了新开发人员的设置。新开发人员可以将应用程序的代码库检出到他们的开发机器上，只需要安装语言运行时和依赖管理器作为先决条件。他们能够通过确定性的构建命令设置运行应用程序代码所需的一切。

例如，Ruby/Bundler的构建命令是bundle install，而Clojure/Leiningen的构建命令是lein deps。

#### 2. 十二要素应用程序不依赖于系统范围内包的隐式存在。

它通过依赖声明清单完全准确地声明所有依赖。此外，它在执行期间使用依赖隔离工具来确保没有隐式依赖从周围系统"泄漏进来"。完整的显式依赖规范在生产和开发中统一应用。

Bundler为Ruby提供了Gemfile清单格式用于依赖声明和bundle exec用于依赖隔离。在Python中，这两个步骤使用两个单独的工具——Pip用于声明，Virtualenv用于隔离。即使是C语言也有Autoconf用于依赖声明，静态链接可以提供依赖隔离。无论工具链如何，依赖声明和隔离必须始终一起使用——只有其中一个不足以满足十二要素。

#### 3. 十二要素应用程序不依赖于任何系统工具的隐式存在。

虽然这些工具可能在许多甚至大多数系统上存在，但不能保证它们在应用程序可能运行的所有系统上都存在，或者未来系统上的版本是否与应用程序兼容。

例如包括调用ImageMagick或curl。

如果应用程序需要调用系统工具，该工具应该被包含到应用程序中。

## III. 配置
### 在环境中存储配置

#### 1. 十二要素应用程序严格分离配置和代码

应用程序的*配置*是指在[部署](./codebase.md)之间可能发生变化的所有内容（预发布、生产、开发环境等）。配置在不同部署之间变化很大；代码则不会。应用程序有时将配置存储为代码中的常量。这违反了十二要素，十二要素要求**严格分离配置和代码**。

判断应用程序是否已将所有配置正确地从代码中分离出来的试金石是，代码库是否可以在任何时候开源，而不会泄露任何凭据。

请注意，这个"配置"的定义**不**包括应用程序内部配置，例如Rails中的`config/routes.rb`，或者Spring中[代码模块如何连接](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html)。这种类型的配置在不同部署之间不会变化，最好在代码中完成。

示例包括：
- 数据库、Memcached和其他[后端服务](./backing-services.md)的资源句柄
- 外部服务（如Amazon S3或Twitter）的凭据
- 每个部署的值，如部署的规范主机名

#### 2. 十二要素应用程序将配置存储在环境变量中

另一种配置方法是使用未检入版本控制的配置文件，例如Rails中的`config/database.yml`。这比使用检入代码仓库的常量有了很大改进，但仍然有弱点：很容易错误地将配置文件检入仓库；配置文件往往分散在不同地方和不同格式中，难以在一个地方查看和管理所有配置。此外，这些格式往往是特定于语言或框架的。

**十二要素应用程序将配置存储在*环境变量*中**（通常简称为*env vars*或*env*）。环境变量易于在不同部署之间更改而无需更改代码；与配置文件不同，它们很少被意外检入代码仓库；与自定义配置文件或其他配置机制（如Java系统属性）不同，它们是语言和操作系统无关的标准。

#### 3. 十二要素应用程序将环境变量视为粒度控制，从不按环境分组

配置管理的另一个方面是分组。有时应用程序将配置批处理为命名的组（通常称为"环境"），以特定部署命名，例如Rails中的`development`、`test`和`production`环境。这种方法不能很好地扩展：随着应用程序创建更多部署，需要新的环境名称，例如`staging`或`qa`。随着项目进一步发展，开发人员可能会添加他们自己的特殊环境，如`joes-staging`，导致配置的组合爆炸，使应用程序部署管理变得非常脆弱。

在十二要素应用程序中，环境变量为每个部署独立管理。它们从不作为"环境"分组，而是被视为粒度控制。这种模型随着应用程序在其生命周期中自然扩展到更多部署而平稳扩展。

## IV. 后端服务
### 将后端服务视为附加资源

#### 1. 十二要素应用程序依赖后端服务进行正常操作。

*后端服务*是应用程序在正常操作过程中通过网络使用的所有服务。

示例包括数据存储（如[MySQL](http://dev.mysql.com/)或[CouchDB](http://couchdb.apache.org/)）、消息/队列系统（如[RabbitMQ](http://www.rabbitmq.com/)或[Beanstalkd](https://beanstalkd.github.io)）、用于外发邮件的SMTP服务（如[Postfix](http://www.postfix.org/)）和缓存系统（如[Memcached](http://memcached.org/)）。

#### 2. 十二要素应用程序将每个不同的后端服务视为可附加资源。

每个不同的后端服务都是一个*资源*，表示其与所附加部署的松耦合。

例如，MySQL数据库是一个资源；两个MySQL数据库（在应用层用于分片）构成两个不同的资源。

资源可以根据需要附加到和从部署中分离。例如，如果应用程序的数据库由于硬件问题而出现问题，应用程序的管理员可能会启动一个新的从最近备份恢复的数据库服务器。当前的生产数据库可以被分离，新数据库可以被附加——所有这些都无需任何代码更改。

#### 3. 十二要素应用程序使用存储在配置中的连接字符串引用所有服务。

像数据库这样的后端服务传统上由部署应用程序运行时的相同系统管理员管理。除了这些本地管理的服务外，应用程序还可能有由第三方提供和管理的服务。十二要素应用程序的代码对本地和第三方服务不作区分；对应用程序来说，两者都是*附加资源*，通过存储在[配置](./config.md)中的URL或其他定位器/凭据访问。

第三方服务的示例包括SMTP服务（如[Postmark](http://postmarkapp.com/)）、指标收集服务（如[New Relic](http://newrelic.com/)或[Loggly](http://www.loggly.com/)）、二进制资产服务（如[Amazon S3](http://aws.amazon.com/s3/)），甚至是可通过API访问的消费者服务（如[Twitter](http://dev.twitter.com/)、[Google Maps](https://developers.google.com/maps/)或[Last.fm](http://www.last.fm/api)）。

应用程序的[部署](./codebase.md)应该能够将本地MySQL数据库替换为第三方管理的数据库（如[Amazon RDS](http://aws.amazon.com/rds/)），而无需对应用程序代码进行任何更改。同样，本地SMTP服务器可以替换为第三方SMTP服务（如Postmark）而无需代码更改。在这两种情况下，只需要更改配置中的资源句柄。
